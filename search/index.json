[{"content":" “我们要在五年内消灭贫困人口”——WDM，彼消灭非此消灭😮？！还是不是段子了…… 那么多内心挣扎与犹豫，本质上就是身体本能与理性意识在干架（🙏遁入佛门~空即是色~色即是空……）。智人变异、选择、进化、学习了这么多年，尚且连自己的身体都无法完全驾驭，果然还是处于文明早期叭——又或者文明的时间尺度根本就不该拿来和宇宙时间尺度相比 …总是倾向于展现自己既渴求、又缺少的部分。而真正擅长或富足的东西是无需刻意表现的。自我审视发现自己也没能免于这个毛病，%【人格系统补丁升级中……】 电子音乐相对于传统音乐更偏重声学而轻乐理，是伐？🤔 警告：长远来看，理想主义者终将建国，否则便是文明的灭亡 这世界上那么多苦难，大都来自于一部分人上人总想骑在他人头上 【嫌い】 死亡对于 🐒 灵长目-人科-智人属-人种 的造物们来说是他们的文明中最大的公平  ","date":"2021-02-05","permalink":"https://izayoi.cn/post/%E7%89%87%E8%AF%AD/","tags":["纸屑"],"title":"片语"},{"content":"  原⽂地址：https://www.usenix.org/legacy/event/osdi08/tech/full_papers/cadar/cadar.pdf\n作者：Cristian Cadar, Daniel Dunbar, Dawson Engler - Stanford University\n翻译：IZAY01\n 0. 概述 KLEE 是我们推出的一款全新的符号执⾏⼯具，它能够对于各种与环境有密集交互的程序，自动生成实现路径高覆盖率的测试用例。借助于KLEE，我们对 GNU 的核⼼组件中的 89 个独⽴程序进⾏了全方位的测试——这些程序为数百万个 Unix 平台构建了核⼼⽤⼾态环境，可以被认为是当下经过了最为严格的测试的程序的集合。KLEE 为其⽣成的测试⽤例的路径覆盖率很高——平均每个程序达到了 90% 以上（中位数更是超过了 94%）。这个成绩⼤⼤超越了开发者⼿动编写的测试集。而当我们对与其相似的 75 个 BUSYBOX 嵌⼊式系统套件中的程序进⾏测试时，结果表现得更为出⾊。在其中的 31 个程序中，路径覆盖率达到了 100%。\n同时，我们也将 KLEE 作为⼀个漏洞扫描器使用，将其应⽤到了 452 个软件应⽤上（这其中包含了超过430,000 ⾏代码），并在其中发掘了 56 个严重的漏洞。其中包含了三个在 15 年间都未曾被发现过的 COREUTILS 中的漏洞。最后，我们使⽤ KLEE 交叉测试了据称是完全相同的 BUSYBOX 和 COREUTILS 的程序集，并在其中找到了逻辑错误和⼤量的不同之处。\n1. 简介 诸如程序功能性错误在内的许多编码错误，在不执⾏⼀些程序代码的情况下是很难被发现的。动态测试对于程序来说⼗分重要，但是不论是随机⽣成测试⽤例还是⼈⼯测试的⽅式，都存在实现困难且执⾏效率低下的问题。所以近年来业内对于如何使⽤符号执⾏来⾃动⽣成测试⽤例，做出了许多研究与⼯作。在宏观上，符号执⾏中的变量不再是⼿动⽣成或随机⽣成的具体值，而是在程序执⾏的过程中，作为⼀个未定值的“符号”。符号执行将被测程序的具体输⼊替换成了符号值，并且将相应的指令操作替换成了对于符号的操作。当程序的执⾏路径分⽀含有符号化的变量时，（概念上的）系统会将每条路径分⽀都遍历⼀遍。此时，其中的每条分⽀路径，都包含了⼀系列到达此分⽀所需要的符号值的约束条件，我们称其为“路径约束”。每当⼀条路径执⾏完毕或是触发错误时，⼀个包含了具体值的测试⽤例就会被⽣成。对于已确定的代码，将这条测试⽤例以具体值的形式作为同⼀份已测试的程序的输⼊，程序就会以原先测试时同样的路径执⾏并触发同样的错误。\n以上结果总归是可以被保证的。然而，当研究者确定了符号执⾏对于一部分程序能够做到良好的测试覆盖率和漏洞 查找效果时，⼀个新的问题就出现了：符号执⾏对于实际的软件能否做到相同的测试效果呢？我们关注的核⼼问题有两点：1、路径爆炸；2、对于程序与诸如OS、NET等相关环境还有⽤⼾的交互的处理（外部环境问题）。⼤多数过去的研究与⼯作（包括我们的⼯作），通常只报告了⼀组有限的⼿⼯基准测试结果，并且基本没有包括任何关于覆盖率的数据，因此对这两个问题都没有太⼤的帮助。\n本篇论⽂主要论述了我们的两点突破。⾸先，我们推出了⼀个全新的、对于各式各样的软件能够发挥强大的深⼊测试能⼒的符号执⾏⼯具—— KLEE。其吸收了我们团队在前⼀个⼯具 EXE 上所积累的数年的经验教训。KLEE 采⽤各种约束求解优化，紧凑地表⽰程序状态，并使⽤试探搜索法获得较⾼的代码覆盖率。此外，KLEE 使⽤了直截了当的⽅案来处理外部环境问题。以上这些特性能够将 KLEE 的性能提⾼⼀个数量级，并做到“开箱即⽤”地检查各种系统交互密集型程序。\n其次，我们证实了使⽤ KLEE ⾃动⽣成的测试⽤例，对各种真实的、复杂的和环境密集型的程序，达到了很高的覆盖率。我们最深⼊的⼀次评估，是将 KLEE 应⽤于面向 GNU COREUTILS 的最新稳定版本（版本6.10）中的全部 89 个程序的测试之中。这其中包含了约 80,000 ⾏库代码，和实际实⽤程序中的 61,000 ⾏代码。这些程序在运⾏时，与其所在的外部环境进⾏了⼤量的交互，以实现各种功能。包括管理⽂件系统（例如 ls 、 dd 、 chmod ），显⽰和配置系统属性（例如 logname 、 printenv ， hostname ），控制命令调⽤（例如 nohup 、 nice 、 env ），处理⽂本⽂件（例如 sort 、 od 、 patch ）等等。它们构建了众多 Unix 系统上的核⼼⽤⼾级环境。数百万⼈每天都在使⽤这些程序，它们中出现的 bugs 能够被及时修复，同时还能定期发布新版本。此外，这些程序与外部环境频繁的交互，正是相当于面向符号执⾏的压⼒测试——而这正是⼀直以来符号执⾏最为薄弱的能⼒。\n此外，寻找 COREUTILS 中的 bugs 是⼀项困难的⼯作。因为 COREUTILS 可以称之为现今经过了最为完备的测试的开源程序套件（举例来讲，在 Unix 下，你还有使用的⽐ ls 更频繁的程序吗？）。1995 年对于⼀部分 COREUTILS 程序的随机测试时发现，与 7 个商⽤ Unix 系统相⽐，它们的故障率要明显更低。最后⼀个 COREUTILS 漏洞被上报到SecurityFocus 或 美国国家漏洞数据库，已经是三年前的事情了。\n另外，我们同时测试了另外两个 Unix 程序套件：BUSYBOX ——⼀个⼴泛应⽤于嵌⼊式系统的发⾏版，以及 MINIX 的最新发⾏版。最后，我们对 HISTAR 操作系统内核代码进⾏了测试，作为与⽤⼾态程序代码测试的对⽐。\n我们的实验分为三类：\n 进⾏密集测试以查找 bugs，同时获得较⾼的覆盖率（面向 COREUTILS、HISTAR 和 75 个 BUSYBOX 程序）； 快速运⾏于⼤量应⽤程序来查找 bugs（面向另外的 204 个 BUSYBOX 程序和 77 个 MINIX 程序）; 交叉检查等效程序，以查找更深层的程序错误（面向 67个 BUSYBOX 程序与 COREUTILS 中的 67 个等效程序）。  由此，我们共在超过 452 个程序上运⾏了 KLEE，其中包含了超过 430,000 ⾏代码。据我们所知，这⽐此前的符号执⾏测试、⽣成用例的⼯作，所检查的代码和程序个数要多出了⼀个数量级。\n通过实验，我们得到了如下结论：\n KLEE 在⼤量复杂程序的测试中，达到了很⾼的覆盖率。其⾃动⽣成的测试⽤例覆盖到了 COREUTILS 中 84.5% 的代码⾏，和 BUSYBOX 中（除去库代码）90.5% 的代码⾏。在对于这些程序的测试中，平均能够覆盖 90% 以上的代码⾏（中位数超过 94%）。并在 16 个 COREUTILS 和 31 个BUSYBOX 程序中达到了 100% 的覆盖率； KLEE 可以得到⽐起持续集中化的⼿动测试，要显著提⾼的代码覆盖率。在⼤约 89 小时的运⾏中，KLEE ⽣成的对 COREUTILS 的代码覆盖测试⽤例的覆盖率，超出了开发者⾃⼰的测试套件（这是一份持续构建了15年的测试套件）16.8%！ KLEE 在原生应⽤程序上达成了⾼覆盖率的测试结果。 唯⼀的例外是 COREUTILS 中的 sort 函数，需要进⾏⼀次操作来缩减过大的缓冲区，而这会给约束求解器带来了麻烦。 KLEE 还在一些经过了严格测试的代码中，发现了严重 bug。其在 COREUTILS 中发现了10个致命 bugs（包括三个 15 年来都没有被发现的 bug），这些 bugs 造成的程序崩溃次数超过 2006、2007 和 2008 年上报的总和。同时，KLEE 还发现了 BUSYBOX 中的 24 个 bugs，MINIX 中的 21 个 bugs 以及 HISTAR 中的⼀个安全漏洞——共计 56 个严重的 bugs。 KLEE 测试⽤例可以在程序的原代码版本上运⾏（⽐如⽤ gcc 编译得到的）——这⼤⼤简化了调试和错误报告。 例如，所有 COREUTILS 中发现的 bugs 都在两天内得到确认并修复，并且 KLEE ⽣成的测试⽤例也包含在其重新发布的版本中。 KLEE 的能⼒也不仅限于发掘低级编程错误：当⽤于交叉检查据称完全相同的 BUSYBOX 和 GNU COREUTILS 程序时，KLEE ⾃动发现了逻辑错误，和两者的⼤量不⼀致之处。 KLEE 同时也可以应⽤于⾮⽤⼾态程序代码。当应⽤于 HISTAR 内核的测试中时，它的平均代码⾏覆盖率达 76.4%（有磁盘 IO）和 67.1%（⽆磁盘 IO），并发现了⼀个严重的漏洞。  下⼀节将概述我们的⽅法。第 3 节我们将介绍 KLEE，并重点介绍其关键的优化。第 4 节讨论如何对程序运行环境进⾏建模。本⽂的核⼼是第 5 节，于此我们呈现了实验结果。最后，第 6 节介绍了相关⼯作，并在第 7 节作出总结。\n2. 综述 本节引导读者通过对 MINIX 中的 tr 工具进行测试来阐述 KLEE 的工作原理。虽然这个小工具的源码只有短短 169 行，但其中的 83 行都是代码。而这 83 行代码恰能很好的用来说明我们测试程序中遇到的两个普遍性问题。\n 复杂性。tr 的主要功能是从它接收到的输入中转换和删除字符。它将它的功能意图很好地隐藏在了隐式的输入解析代码、棘手的边界条件，和难以追溯的控制流之下。图1中，我们给出了一个具有代表性的代码片段。 环境依赖性。来自系统环境中的输入值控制了大部分 tr 代码的执行流。命令行参数决定了哪些子程序被执行，输入值则决定了哪条 if 分支被执行，而程序执行则取决于从文件系统读入的能力。同时，程序要能够得当地处理无效或非法的输入。对所有重要的值和边界情况进行测试，这并非一件易事。  1 : void expand(char *arg, unsigned char *buffer) { 8 2 : int i, ac; 9 3 : while (*arg) { 10* 4 : if (*arg == ’\\\\’) { 11* 5 : arg++; 6 : i = ac = 0; 7 : if (*arg \u0026gt;= ’0’ \u0026amp;\u0026amp; *arg \u0026lt;= ’7’) { 8 : do { 9 : ac = (ac \u0026lt;\u0026lt; 3) + *arg++ − ’0’; 10: i++; 11: } while (i\u0026lt;4 \u0026amp;\u0026amp; *arg\u0026gt;=’0’ \u0026amp;\u0026amp; *arg\u0026lt;=’7’); 12: *buffer++ = ac; 13: } else if (*arg != ’\\0’) 14: *buffer++ = *arg++; 15: } else if (*arg == ’[’) { 12* 16: arg++; 13 17: i = *arg++; 14 18: if (*arg++ != ’-’) { 15! 19: *buffer++ = ’[’; 20: arg −= 2; 21: continue; 22: } 23: ac = *arg++; 24: while (i \u0026lt;= ac) *buffer++ = i++; 25: arg++; /* Skip ’]’ */ 26: } else 27: *buffer++ = *arg++; 28: } 29: } 30: . . . 31: int main(int argc, char* argv[ ]) { 1 32: int index = 1; 2 33: if (argc \u0026gt; 1 \u0026amp;\u0026amp; argv[index][0] == ’-’) { 3* 34: . . . 4 35: } 5 36: . . . 6 37: expand(argv[index++], index); 7 38: . . . 39: }   图1：以上是本文所检查的具有代表性的 MINIX tr 的代码片段。既复杂又隐晦，且难以通过检查或测试进行验证。右侧编号记录了出现于第十八行的错误所经过的执行流的代码行顺序。\n 这段代码还具有另外两个被测程序中普遍存在的特性。首先，它含有 bugs，而这正是 KLEE 生成测试用例与进行检测的目的。其次，KLEE 能够于其上很快达成可观的路径覆盖率：KLEE 在两分钟内为其生成了 37 条测试用例，覆盖了程序中的所有路径。\nKLEE 有两个目标：（1）覆盖所有程序中的路径；（2）在输入触发程序错误时，能够探测每个危险操作（如解引用、断言）。KLEE 通过符号执行来达成目标：不同于直接执行程序时，指令自操作数获取具体值。符号执行生成到达这条路径所要求的变量值的约束条件。而当 KLEE 探测到错误发生，或程序进行了 exit 系统调用时，KLEE 就对当前路径的约束条件进行约束求解，由此为程序的原始版本生成能够完全复现路径的测试用例。\nKLEE 的设计，旨在生成测试用例，使得原始程序所遵循的路径始终遵循 KLEE 测试时所采用的相同路径（即没有误报）。然而，KLEE 所检查的代码和 bugs 中的不确定性，在实践过程中产生了误报。结合 gdb 和 gcov 等标准工具，在 KLEE 之外重新运行测试的能力，对于诊断此类错误并验证我们的结果来说非常宝贵。\n接下来我们会展示 KLEE 的使用方法，并给出关于 KLEE 工作方式的综述。\n2.1 使用方式 使用者可以很方便地使用 KLEE 来开始他的对于许多真实程序的测试任务：通常情况下 KLEE 是不需要源代码层面的定制，或是一些人工修改，就能够很好的完成工作的。用户首先需要使用公开发布的 LLVM for GNU C，将程序的源码编译成 LLVM 字节码。如我们使用了如下命令编译 tr：\nllvm-gcc --emit-llvm -c tr.c -o tr.bc\n然后，用户在生成的 LLVM 字节码的层面上运行 KLEE。并可以对被测程序指定符号输入的数量、大小和类型。对于 tr，我们使用如下命令：\nklee --max-time 2 --sym-args 1 10 10 --sym-files 2 2000 --max-fail 1 tr.bc\n这条命令的第一个参数 --max-time，告诉 KLEE 对于 tr.bc 至多运行两分钟测试。其余参数则描述了符号化输入。--sym-args1 10 10 参数说明了我们使用 0 来填充三个命令行参数。其中，第一个命令行参数长度为 1 字符，其余两个长度为 10 字符。--sym-files 2 2000 则用于说明要使用标准输入和一个文件，这两者都包含了 2000 字节的符号化数据。最后，--max-fail 1 参数规定了，在每条测试路径上最多只能出现一次系统调用失败。\n","date":"2021-02-03","permalink":"https://izayoi.cn/post/klee_%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%AB%98%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E6%B5%8B%E8%AF%95/","tags":["二进制安全"],"title":"KLEE_为复杂系统程序自动生成高覆盖率的测试"},{"content":"  2020，21岁，终于有了些许对自己生活的掌控感。少了些许迷茫，确定了些航向。前四五年裹挟我的愤怒、哀愁、自卑、焦虑与迷茫，这些阴霾在今天约摸消散过半。自己的人生仿佛色彩可期，灰暗与单调不再。而 2020 年这场天灾，恰好似黎明前的黑暗。\n——“明天会更好”\n似乎现在正是最能够道出这句话的时机。可转念一想，个体 加 环境，才等于我的明天。而对于后者，一股悲观的情绪萦绕心头。明天真的会更好吗？2020 不仅成为了我的，更是成为了整个世界的拐点。未来难以预测，一成不变的是我依然只是风浪中的一叶——无论是轻风和浪，还是惊涛骇浪。\n2020 的风浪，则是将我留在了北方。\n这是不断做减法的一年。我不再焦虑地如同无头苍蝇一般，用无谓的汗水去“充实”自己的生活。这一年，与各种各样的事务、形形色色的人的联结，先升后降。递减到今天，我的生活包含了一个不大不小、恰如其分的集合——只留下了我真正需要、真正想要的那一部分。盛年的精力总归是一段人生中极为珍贵的不可再生资源 （果然人类是有极限的叭！） ，而我现在正努力地将其倾注到我人生单一且关键的位置。\n","date":"2021-02-02","permalink":"https://izayoi.cn/post/%E8%AE%B0-2020/","tags":["时光"],"title":"记 2020"}]